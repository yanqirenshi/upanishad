(in-package :upanishad)

(defun restore-objects (pool type)
  (assert (snapshot-type-p type))
  (let ((deserializer (deserializer pool))
        (serialization-state (serialization-state pool)))
    (when (probe-file (snapshot-pathnames pool type))
      (with-open-file (in (snapshot-pathnames pool type) :direction :input)
        (cond ((eq type :object)
               (setf (root-objects pool)
                     (funcall deserializer in serialization-state)))
              ((eq type :index)
               (setf (index-objects pool)
                     (funcall deserializer in serialization-state)))
              ((eq type :memes)
               (setf (memes pool)
                     (funcall deserializer in serialization-state)))
              ((eq type :indexes)
               (setf (indexes pool)
                     (funcall deserializer in serialization-state)))))))
  pool)

(defun restore-transaction-log (pool)
  (when (probe-file (transaction-log pool))
    (let ((position 0))
      (handler-bind ((s-xml:xml-parser-error
                       #'(lambda (condition)
                           (format *standard-output*
                                   ";; Warning: error during transaction log restore: ~s~%"
                                   condition)
                           (truncate-file (transaction-log pool) position)
                           (return-from restore-transaction-log))))
        (with-open-file (in (transaction-log pool) :direction :input)
          (loop
            (let ((transaction (funcall (deserializer pool) in (serialization-state pool))))
              (setf position (file-position in))
              (if transaction
                  (execute-on transaction pool)
                  (return))))))))
  pool)

(defmethod restore ((pool pool))
  (clrhash (root-objects pool))
  (close-open-streams pool)
  (restore-objects pool :object)
  (restore-objects pool :index)
  (restore-objects pool :memes)
  (restore-objects pool :indexes)
  (restore-transaction-log pool)
  pool)
